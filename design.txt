We decided to use Ruby on Rails as the programming language with which we implemented our website. On the one hand, the level of abstraction was much higher than we’ve seen so far, but on the other, it is simply a powerful tool that takes care of minutia for us. It took us a while to understand how it works, but we ended up appreciating its abilities, and could understand why it is currently one of the most popular languages for web development. Furthermore, its popularity allowed us to get a lot of support on line, extending from RoR’s own manual, to the much beloved Stack overflow. 

In order to implement this project, we used the “CS 50 Twitter” example from the Ruby on Rails seminar as a starting point, simultaneously learning the syntax and inner workings of Ruby on Rails and tweaking the example code. Using the Ruby on Rails tutorial online, we enhanced our skills by implementing most of the examples, in order to familiarize ourselves with the process for creating models, controllers, and views in Rails. With the help of Shadi’s cousin, who studied Electrical Engineering and now works in software development with the Harvard Humanitarian Initiative, we were able to make ourselves more comfortable with Rails and work through the unfamiliar errors that would arise periodically. 

Since the CS 50 Twitter example implemented a user model pretty similar to the one that we had envisioned for our project, we decided to next tackle a Comments model, utilizing the online tutorial as a guide. In order to enable Conversaid users to comment on posts, we first generated a file called comment.rb, such that each comment would be linked to a particular user and post. The next step was to create the Comments controller (comments_controller.rb) in which we defined functions for the creation and deletion of the comments. The remaining step was to create the comments view, which rather than coding in a new file, we simply added to a view that we created to display each post. The idea is that if a user reads a post on the feed on which they would like to comment, they can simply click on the post and comment.

The Tweet model in the seminar source code provided much of the functionality that we hoped to implement in our own program, so we used it as the basis for our Post model. When we implemented categories for our posts, we had to add a few more functions to the Tweet controller, namely index_category and get_ordering_string(params); we also added show and adv, which we will delve into in greater detail in a bit. Notably, we decided to include the categories attributes within our original posts table, instead of creating a new one - so as to conserve memory and, let’s admit it, lines of code. We believe it made both our code and the implementation of the website more efficient (e.g. when selecting from the table, we didn’t have to integrate code addressing two different tables, but instead could use one line of code). Another feature that we implemented in the Post model, was the option to sort posts in the feed by creation time, rating, or randomly. We added links to these functions to the view (_post.html.erb) and defined them in Post controller, as def index_category. Instead of creating a new view for each of the ways that the feed can be ordered, in each function we defined the array of posts, ordered as the user input indicates, with the same variable (@posts), so that in the view, we could simply display each item in (@posts), in whichever order they happened to be ordered.

When a user creates a new post, they have the option of tagging the post with one or more of the six provided categories, which will be recorded in the appropriate field of the Post model. On the back end, we retrieved posts that were tagged with each category, and provided links to the filtered feeds on show.html.erb. Additionally, we implemented a shuffle option, so that the user could obtain a “random” topic from the posts table. We chose to add a condition that would check the parameter in the url that comes after ‘/category’, for either a category or ‘random’. The category option would render the view filtered to include only the posts associated with that category; the random option would assign @posts to a random post retrieved from the table. 

We created a Vote MVC in order to enable the user to like or dislike each post. In the model, each vote is associated with a post and a user, each User and Post is allowed to have many votes. In vote_controller.rb, we defined the function vote, which through several conditions, determined whether a user intended to like or dislike a post, whether a user was allowed to vote (each user is afforded a single like/dislike), and updated the appropriate value in the Vote table and the rating value in the Post table. The like and dislike links were added to the show.html.erb view, since we wanted users to be able to like/dislike and/or comment any post from the same view. 

The final model that we implemented was word.rb, with the purpose of creating a word scrambler. We entered words into the table (defined in the word model), from which we can now randomly retrieve two words and generate a phrase, using the adv function in the Post controller, and display on the adv.html.erb. A link to this “Adventurous” feature was included on the _post.html.erb, so that users can select it just as they would a category or the shuffle feature. 

We also adjusted the existing profile view to include a listing of the posts that were created by the current user, again by retrieving posts based on user_id and rendering them on the profile.html.erb view.


